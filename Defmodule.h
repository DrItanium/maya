/*******************************************************/
/*      "C" Language Integrated Production System      */
/*                                                     */
/*             CLIPS Version 6.40  08/25/16            */
/*                                                     */
/*                DEFMODULE HEADER FILE                */
/*******************************************************/

/*************************************************************/
/* Purpose: Defines basic defmodule primitive functions such */
/*   as allocating and deallocating, traversing, and finding */
/*   defmodule data structures.                              */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Gary D. Riley                                        */
/*                                                           */
/* Contributing Programmer(s):                               */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Revision History:                                         */
/*                                                           */
/*      6.23: Correction for FalseSymbol/TrueSymbol. DR0859  */
/*                                                           */
/*            Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*      6.24: Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*      6.30: Changed integer type/precision.                */
/*                                                           */
/*            Removed conditional code for unsupported       */
/*            compilers/operating systems (IBM_MCW,          */
/*            MAC_MCW, and IBM_TBC).                         */
/*                                                           */
/*            Added const qualifiers to remove C++           */
/*            deprecation warnings.                          */
/*                                                           */
/*            Converted API macros to function calls.        */
/*                                                           */
/*      6.40: Removed LOCALE definition.                     */
/*                                                           */
/*            Pragma once and other inclusion changes.       */
/*                                                           */
/*            Added support for booleans with <stdbool.h>.   */
/*                                                           */
/*            Removed use of void pointers for specific      */
/*            data structures.                               */
/*                                                           */
/*            ALLOW_ENVIRONMENT_GLOBALS no longer supported. */
/*                                                           */
/*            UDF redesign.                                  */
/*                                                           */
/*************************************************************/

#ifndef _H_moduldef

#pragma once

#define _H_moduldef

typedef struct defmodule Defmodule;
typedef struct portItem PortItem;
typedef struct defmoduleItemHeader DefmoduleItemHeader;
typedef struct moduleItem ModuleItem;
typedef struct moduleStackItem ModuleStackItem;

typedef void *AllocateModuleFunction(const Environment::Ptr&);
typedef void FreeModuleFunction(const Environment::Ptr&, void *);

enum class ConstructType {
    DEFMODULE,
    DEFRULE,
    DEFTEMPLATE,
    DEFFACTS,
    DEFGLOBAL,
    DEFFUNCTION,
    DEFGENERIC,
    DEFMETHOD,
    DEFCLASS,
    DEFMESSAGE_HANDLER,
    DEFINSTANCES
};

#include <cstdio>
#include "Entities.hxx"
#include "UserData.h"
#include "Utility.h"

struct ConstructHeader {
public:
    using Self = ConstructHeader;
    using Ptr = std::shared_ptr<Self>;
public:
    ConstructType constructType;
    CLIPSLexeme::Ptr name;
    std::string ppForm;
    std::shared_ptr<DefmoduleItemHeader> whichModule;
    unsigned long bsaveID = 0;
    Ptr next;
    struct userData *usrData;
    Environment env;
};

struct defmoduleItemHeader {
    std::shared_ptr<Defmodule> theModule;
    ConstructHeader::Ptr firstItem;
    ConstructHeader::Ptr lastItem;
};

typedef ConstructHeader *FindConstructFunction(const Environment::Ptr&, const char *);
typedef ConstructHeader *GetNextConstructFunction(const Environment::Ptr&, ConstructHeader *);
typedef bool IsConstructDeletableFunction(ConstructHeader *);
typedef bool DeleteConstructFunction(ConstructHeader *, const Environment::Ptr&);
typedef void FreeConstructFunction(const Environment::Ptr&, ConstructHeader *);

/**********************************************************************/
/* defmodule                                                          */
/* ----------                                                         */
/* name: The name of the defmodule (stored as a reference in the      */
/*   table).                                                          */
/*                                                                    */
/* ppForm: The pretty print representation of the defmodule (used by  */
/*   the save and ppdefmodule commands).                              */
/*                                                                    */
/* itemsArray: An array of pointers to the module specific data used  */
/*   by each construct specified with the RegisterModuleItem          */
/*   function. The data pointer stored in the array is allocated by   */
/*   the allocateFunction in moduleItem data structure.               */
/*                                                                    */
/* importList: The list of items which are being imported by this     */
/*   module from other modules.                                       */
/*                                                                    */
/* next: A pointer to the next defmodule data structure.              */
/**********************************************************************/

struct defmodule {
public:
    using Self = defmodule;
    using Ptr = std::shared_ptr<Self>;
public:
    ConstructHeader header;
    DefmoduleItemHeader **itemsArray;
    PortItem *importList;
    PortItem *exportList;
    bool visitedFlag;
};

struct portItem {
public:
    using Self = defmodule;
    using Ptr = std::shared_ptr<Self>;
public:
    CLIPSLexeme::Ptr moduleName;
    CLIPSLexeme::Ptr constructType;
    CLIPSLexeme::Ptr constructName;
    Ptr next;
};

#define MIHS (DefmoduleItemHeader *)

/**********************************************************************/
/* moduleItem                                                         */
/* ----------                                                         */
/* name: The name of the construct which can be placed in a module.   */
/*   For example, "defrule".                                          */
/*                                                                    */
/* allocateFunction: Used to allocate a data structure containing all */
/*   pertinent information related to a specific construct for a      */
/*   given module. For example, the deffacts construct stores a       */
/*   pointer to the first and last deffacts for each each module.     */
/*                                                                    */
/* freeFunction: Used to deallocate a data structure allocated by     */
/*   the allocateFunction. In addition, the freeFunction deletes      */
/*   all constructs of the specified type in the given module.        */
/*                                                                    */
/* bloadModuleReference: Used during a binary load to establish a     */
/*   link between the defmodule data structure and the data structure */
/*   containing all pertinent module information for a specific       */
/*   construct.                                                       */
/*                                                                    */
/* findFunction: Used to determine if a specified construct is in a   */
/*   specific module. The name is the specific construct is passed as */
/*   a string and the function returns a pointer to the specified     */
/*   construct if it exists.                                          */
/*                                                                    */
/* exportable: If true, then the specified construct type can be      */
/*   exported (and hence imported). If false, it can't be exported.   */
/*                                                                    */
/* next: A pointer to the next moduleItem data structure.             */
/**********************************************************************/
#if STUBBING_INACTIVE
typedef void *AllocateModuleFunction(const Environment::Ptr&);
typedef void FreeModuleFunction(const Environment::Ptr&, void *);
typedef ConstructHeader *FindConstructFunction(const Environment::Ptr&, const char *);
typedef ConstructHeader *GetNextConstructFunction(const Environment::Ptr&, ConstructHeader *);
typedef bool IsConstructDeletableFunction(ConstructHeader *);
typedef bool DeleteConstructFunction(ConstructHeader *, const Environment::Ptr&);
typedef void FreeConstructFunction(const Environment::Ptr&, ConstructHeader *);
#endif
struct moduleItem {
public:
    using Self = moduleItem;
    using Ptr = std::shared_ptr<Self>;
public:
    const char *name;
    unsigned moduleIndex;
    AllocateModuleFunction* allocateFunction;
    FreeModuleFunction* freeFunction;
    void *(*bloadModuleReference)(const Environment::Ptr&, unsigned long);
    FindConstructFunction *findFunction;
    Ptr next;
};

struct moduleStackItem {
public:
    using Self = moduleStackItem;
    using Ptr = std::shared_ptr<Self>;
public:
    bool changeFlag;
    Defmodule *theModule;
    Ptr next;
};

constexpr auto DEFMODULE_DATA = 4;

struct defmoduleData : public EnvironmentModule {
    moduleItem::Ptr LastModuleItem;
    struct voidCallFunctionItem *AfterModuleChangeFunctions;
    ModuleStackItem::Ptr ModuleStack;
    bool CallModuleChangeFunctions;
    Defmodule::Ptr ListOfDefmodules;
    Defmodule::Ptr CurrentModule;
    Defmodule::Ptr LastDefmodule;
    unsigned NumberOfModuleItems;
    struct moduleItem *ListOfModuleItems;
    long ModuleChangeIndex;
    bool MainModuleRedefinable;
    struct portConstructItem *ListOfPortConstructItems;
    unsigned short NumberOfDefmodules;
    struct voidCallFunctionItem *AfterModuleDefinedFunctions;
#if (BLOAD_AND_BSAVE)
    unsigned long BNumberOfDefmodules;
    unsigned long NumberOfPortItems;
    struct portItem *PortItemArray;
    Defmodule *DefmoduleArray;
#endif
};
RegisterEnvironmentModule(defmoduleData, DEFMODULE_DATA, Defmodule);

void InitializeDefmodules(const Environment::Ptr&);
Defmodule *FindDefmodule(const Environment::Ptr&, const char *);
const char *DefmoduleName(Defmodule *);
const char *DefmodulePPForm(Defmodule *);
Defmodule *GetNextDefmodule(const Environment::Ptr&, Defmodule *);
void RemoveAllDefmodules(const Environment::Ptr&, void *);
int AllocateModuleStorage();
unsigned RegisterModuleItem(const Environment::Ptr&theEnv,
                            const char *theItem,
                            AllocateModuleFunction *allocateFunction,
                            FreeModuleFunction *freeFunction,
                            void *(*bloadModuleReference)(const Environment::Ptr&, unsigned long),
                            FindConstructFunction *findFunction);
void *GetModuleItem(const Environment::Ptr&, Defmodule *, unsigned);
void SetModuleItem(const Environment::Ptr&, Defmodule *, unsigned, void *);
Defmodule *GetCurrentModule(const Environment::Ptr&);
Defmodule *SetCurrentModule(const Environment::Ptr&, Defmodule *);
void GetCurrentModuleCommand(const Environment::Ptr&theEnv, UDFContext *context, UDFValue *ret);
void SetCurrentModuleCommand(const Environment::Ptr&theEnv, UDFContext *context, UDFValue *ret);
unsigned GetNumberOfModuleItems(const Environment::Ptr&);
void CreateMainModule(const Environment::Ptr&, void *);
void SetListOfDefmodules(const Environment::Ptr&, Defmodule *);
struct moduleItem *GetListOfModuleItems(const Environment::Ptr&);
struct moduleItem *FindModuleItem(const Environment::Ptr&, const char *);
void SaveCurrentModule(const Environment::Ptr&);
void RestoreCurrentModule(const Environment::Ptr&);
void AddAfterModuleChangeFunction(const Environment::Ptr&, const char *, VoidCallFunction *, int, void *);
void IllegalModuleSpecifierMessage(const Environment::Ptr&);
void AllocateDefmoduleGlobals(const Environment::Ptr&);
unsigned short GetNumberOfDefmodules(const Environment::Ptr&);

#endif /* _H_moduldef */


