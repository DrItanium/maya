/*******************************************************/
/*      "C" Language Integrated Production System      */
/*                                                     */
/*            CLIPS Version 6.40  10/03/19             */
/*                                                     */
/*                    AGENDA MODULE                    */
/*******************************************************/

/*************************************************************/
/* Purpose:                                                  */
/*   Provides functionality for examining, manipulating,     */
/*   adding, and removing activations from the agenda.       */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Gary D. Riley                                        */
/*                                                           */
/* Contributing Programmer(s):                               */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Revision History:                                         */
/*      6.23: Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*      6.24: Removed CONFLICT_RESOLUTION_STRATEGIES         */
/*            and DYNAMIC_SALIENCE compilation flags.        */
/*                                                           */
/*            Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*            Added EnvGetActivationBasisPPForm function.    */
/*                                                           */
/*      6.30: Added salience groups to improve performance   */
/*            with large numbers of activations of different */
/*            saliences.                                     */
/*                                                           */
/*            Borland C (IBM_TBC) and Metrowerks CodeWarrior */
/*            (MAC_MCW, IBM_MCW) are no longer supported.    */
/*                                                           */
/*            Support for long long integers.                */
/*                                                           */
/*            Added const qualifiers to remove C++           */
/*            deprecation warnings.                          */
/*                                                           */
/*            Converted API macros to function calls.        */
/*                                                           */
/*      6.40: Added Env prefix to GetEvaluationError and     */
/*            SetEvaluationError functions.                  */
/*                                                           */
/*            Pragma once and other inclusion changes.       */
/*                                                           */
/*            Added support for booleans with <stdbool.h>.   */
/*                                                           */
/*            Removed use of void pointers for specific      */
/*            data structures.                               */
/*                                                           */
/*            ALLOW_ENVIRONMENT_GLOBALS no longer supported. */
/*                                                           */
/*            UDF redesign.                                  */
/*                                                           */
/*************************************************************/

#include <cstdio>
#include <cstring>

#include "Setup.h"
#include "ArgumentAccess.h"
#include "Constants.h"
#include "ConflictResolutionStrategy.h"
#include "Engine.h"
#include "Environment.h"
#include "ExternalFunctions.h"
#include "MemoryAllocation.h"
#include "Defmodule.h"
#include "DefmoduleUtility.h"
#include "Multifield.h"
#include "PrintUtility.h"
#include "ReteUtility.h"
#include "Retract.h"
#include "Router.h"
#include "BasicRuleCommands.h"
#include "Defrule.h"
#include "StringRouter.h"
#include "SystemDependency.h"
#include "Watch.h"

#include "Agenda.h"
#include <memory>

/***************************************/
/* LOCAL INTERNAL FUNCTION DEFINITIONS */
/***************************************/

static void PrintActivation(const Environment&, const char *, Activation::Ptr );
static void AgendaClearFunction(const Environment&, void *);
static const char *SalienceEvaluationName(SalienceEvaluationType);
static int EvaluateSalience(const Environment&, Defrule::Ptr );
static struct SalienceGroup *ReuseOrCreateSalienceGroup(const Environment&, struct defruleModule *, int);
static struct SalienceGroup *FindSalienceGroup(defruleModule *, int);
static void RemoveActivationFromGroup(const Environment&, Activation::Ptr , struct defruleModule *);

/*************************************************/
/* InitializeAgenda: Initializes the activations */
/*   watch item and the H/L commands for         */
/*   manipulating the agenda.                    */
/*************************************************/
void InitializeAgenda(
        const Environment&theEnv) {
    theEnv->allocateEnvironmentModule<AgendaModule>();
    AddClearFunction(theEnv, "agenda", AgendaClearFunction, 0, nullptr);
#if DEBUGGING_FUNCTIONS
    AddWatchItem(theEnv, "activations", 1, &AgendaData(theEnv)->WatchActivations, 40, DefruleWatchAccess, DefruleWatchPrint);
#endif
    AddUDF(theEnv, "refresh", "v", 1, 1, "y", RefreshCommand);
    AddUDF(theEnv, "refresh-agenda", "v", 0, 1, "y", RefreshAgendaCommand);
    AddUDF(theEnv, "get-salience-evaluation", "y", 0, 0, nullptr, GetSalienceEvaluationCommand);
    AddUDF(theEnv, "set-salience-evaluation", "y", 1, 1, "y", SetSalienceEvaluationCommand);

#if DEBUGGING_FUNCTIONS
    AddUDF(theEnv, "agenda", "v", 0, 1, "y", AgendaCommand);
#endif
}

/*****************************************************************/
/* AddActivation: Creates a rule activation to be added to the   */
/*   Agenda and links the activation with its associated partial */
/*   match. The function PlaceActivation is then called to place */
/*   the activation on the Agenda. Typically called when all     */
/*   patterns on the LHS of a rule have been satisfied.          */
/*****************************************************************/
void AddActivation(
        const Environment&theEnv,
        Defrule::Ptr theRule,
        PartialMatch *binds) {
    defruleModule *theModuleItem;
    SalienceGroup *theGroup;

    /*=======================================*/
    /* Focus on the module if the Activation::Ptr /
    /* is from an auto-focus rule.           */
    /*=======================================*/

    if (theRule->autoFocus) { Focus(theRule->header.whichModule->theModule); }

    /*=======================================================*/
    /* Create the activation. The activation stores pointers */
    /* to its associated partial match and defrule. The      */
    /* activation is given a time tag, its salience is       */
    /* evaluated, and it is assigned a random number for use */
    /* with the random conflict resolution strategy.         */
    /*=======================================================*/

    auto newActivation = get_struct(theEnv, Activation);
    newActivation->setRule(theRule);
    newActivation->setBasis(binds);
    newActivation->setTimetag(AgendaData(theEnv)->newTimetag());
    newActivation->setSalience(EvaluateSalience(theEnv, theRule));

    newActivation->setRandomID(genrand());
    newActivation->setPrevious(nullptr);
    newActivation->setNext(nullptr);

    AgendaData(theEnv)->incrementActivationCount();

    /*=======================================================*/
    /* Point the partial match to the activation to complete */
    /* the link between the join network and the agenda.     */
    /*=======================================================*/

    binds->marker = newActivation;

    /*====================================================*/
    /* If activations are being watch, display a message. */
    /*====================================================*/

#if DEBUGGING_FUNCTIONS
    if (newActivation->getRule()->watchActivation &&
        (!ConstructData(theEnv)->ClearReadyInProgress) &&
        (!ConstructData(theEnv)->ClearInProgress)) {
        WriteString(theEnv, STDOUT, "==> Activation ");
        PrintActivation(theEnv, STDOUT, newActivation);
        WriteString(theEnv, STDOUT, "\n");
    }
#endif

    /*=====================================*/
    /* Place the activation on the agenda. */
    /*=====================================*/

    theModuleItem = (defruleModule *) theRule->header.whichModule;

    theGroup = ReuseOrCreateSalienceGroup(theEnv, theModuleItem, newActivation->getSalience());

    PlaceActivation(theEnv, &(theModuleItem->agenda), newActivation, theGroup);
}

/*******************************/
/* ReuseOrCreateSalienceGroup: */
/*******************************/
static struct SalienceGroup *ReuseOrCreateSalienceGroup(
        const Environment&theEnv,
        struct defruleModule *theRuleModule,
        int salience) {
    struct SalienceGroup *theGroup, *lastGroup, *newGroup;

    for (lastGroup = nullptr, theGroup = theRuleModule->groupings;
         theGroup != nullptr;
         lastGroup = theGroup, theGroup = theGroup->getNext()) {
        if (theGroup->getSalience() == salience) { return (theGroup); }

        if (theGroup->getSalience() < salience) { break; }
    }

    newGroup = get_struct(theEnv, SalienceGroup);
    zeroMemory(newGroup);
    newGroup->setSalience(salience);
    newGroup->setFirst(nullptr);
    newGroup->setLast(nullptr);
    newGroup->setNext(theGroup);
    newGroup->setPrevious(lastGroup);

    if (newGroup->getNext()!= nullptr) { newGroup->getNext()->setPrevious(newGroup); }

    if (newGroup->getPrevious() != nullptr) { newGroup->getPrevious()->setNext(newGroup); }

    if (lastGroup == nullptr) { theRuleModule->groupings = newGroup; }

    return newGroup;
}

/**********************/
/* FindSalienceGroup: */
/**********************/
static struct SalienceGroup *FindSalienceGroup(
        struct defruleModule *theRuleModule,
        int salience) {
    struct SalienceGroup *theGroup;

    for (theGroup = theRuleModule->groupings;
         theGroup != nullptr;
         theGroup = theGroup->getNext()) {
        if (theGroup->getSalience() == salience) { return (theGroup); }

        if (theGroup->getSalience() < salience) { break; }
    }

    return nullptr;
}

/***************************************************************/
/* ClearRuleFromAgenda: Clears the agenda of a specified rule. */
/***************************************************************/
void ClearRuleFromAgenda(
        const Environment&theEnv,
        Defrule::Ptr theRule) {
    Defrule::Ptr tempRule;
    struct Activation::Ptr agendaPtr, *agendaNext;

    /*============================================*/
    /* Get a pointer to the agenda for the module */
    /* in which the rule is contained.            */
    /*============================================*/

    agendaPtr = ((defruleModule *) theRule->header.whichModule)->agenda;

    /*==============================================*/
    /* Loop through every activation on the agenda. */
    /*==============================================*/

    while (agendaPtr != nullptr) {
        agendaNext = agendaPtr->getNext();

        /*========================================================*/
        /* Check each disjunct of the rule against the Activation::Ptr /
        /* to determine if the activation points to the rule. If  */
        /* it does, then remove the activation from the agenda.   */
        /*========================================================*/

        for (tempRule = theRule;
             tempRule != nullptr;
             tempRule = tempRule->disjunct) {
            if (agendaPtr->getRule() == tempRule) {
                RemoveActivation(theEnv, agendaPtr, true, true);
                break;
            }
        }

        agendaPtr = agendaNext;
    }
}

/***************************************************************/
/* GetNextActivation: Returns an activation from the Agenda.   */
/*   If its argument is nullptr, then the first activation on the */
/*   Agenda is returned. If its argument is not nullptr, the next */
/*   activation after the argument is returned.                */
/***************************************************************/
Activation::Ptr GetNextActivation(
        const Environment&theEnv,
        Activation::Ptr actPtr) {
    if (actPtr == nullptr) {
        auto theModuleItem = (defruleModule *) GetModuleItem(theEnv, nullptr, DefruleData(theEnv)->DefruleModuleIndex);
        if (theModuleItem == nullptr) return nullptr;
        return theModuleItem->agenda;
    } else { return actPtr->getNext(); }
}

/*********************************************/
/* GetActivationBasis: Returns the basis of  */
/*   the rule associated with an activation. */

/*********************************************/
/* ActivationRuleName: Returns the name of   */
/*   the rule associated with an activation. */
/*********************************************/
const char *ActivationRuleName(
        Activation::Ptr actPtr) {
    return actPtr->getRule()->header.name->contents;
}

void
Activation::getPPForm(StringBuilder* theSB) noexcept {
    auto theEnv = theRule->header.env;
    OpenStringBuilderDestination(theEnv, "ActPPForm", theSB);
    PrintActivation(theEnv, "ActPPForm", this);
    CloseStringBuilderDestination(theEnv, "ActPPForm");
}

/****************************************************/
/* GetActivationBasisPPForm: Returns the pretty     */
/*   print representation of an activation's basis. */
/****************************************************/
void GetActivationBasisPPForm(
        const Environment&theEnv,
        char *buffer,
        size_t bufferLength,
        Activation::Ptr theActivation) {
    OpenStringDestination(theEnv, "ActPPForm", buffer, bufferLength);
    PrintPartialMatch(theEnv, "ActPPForm", theActivation->getBasis());
    CloseStringDestination(theEnv, "ActPPForm");
}

/********************************************/
/* MoveActivationToTop: Moves the specified */
/*   activation to the top of the agenda.   */
/********************************************/
bool MoveActivationToTop(
        const Environment&theEnv,
        Activation::Ptr theActivation) {
    struct Activation::Ptr prevPtr;
    struct defruleModule *theModuleItem;

    /*====================================*/
    /* Determine the module of the agenda */
    /* in which the activation is stored. */
    /*====================================*/

    theModuleItem = (defruleModule *) theActivation->getRule()->header.whichModule;

    /*============================================*/
    /* If the activation is already at the top of */
    /* the agenda, then nothing needs to be done. */
    /*============================================*/

    if (theActivation == theModuleItem->agenda) return false;

    /*=================================================*/
    /* Update the pointers of the activation preceding */
    /* and following the activation being moved.       */
    /*=================================================*/

    prevPtr = theActivation->getPrevious();
    prevPtr->setNext(theActivation->getNext());
    if (theActivation->getNext() != nullptr) theActivation->getNext()->setPrevious(prevPtr);

    /*=======================================================*/
    /* Move the activation and then update its pointers, the */
    /* pointers of the activation following it, and the      */
    /* module pointer to the top activation on the agenda.   */
    /*=======================================================*/

    theActivation->setNext(theModuleItem->agenda);
    theModuleItem->agenda->setPrevious(theActivation);
    theActivation->setPrevious(nullptr);
    theModuleItem->agenda = theActivation;

    /*=============================*/
    /* Mark the agenda as changed. */
    /*=============================*/

    AgendaData(theEnv)->markAgendaHasChanged();

    return true;
}

/*******************************************/
/* DeleteActivation: Removes the specified */
/*   activation from the agenda.           */
/*******************************************/
void DeleteActivation(
        Activation::Ptr theActivation) {
    RemoveActivation(theActivation->getRule()->header.env, theActivation, true, true);
}

/*************************************************/
/* DeleteAllActivations: Removes all activations */
/*   from the agenda of the specified module.    */
/*************************************************/
void DeleteAllActivations(
        Defmodule *theModule) {
    const Environment& theEnv = theModule->header.env;

    auto theActivation = GetDefruleModuleItem(theEnv, nullptr)->agenda;
    while (theActivation != nullptr) {
        auto tempPtr = theActivation->getNext();
        RemoveActivation(theEnv, theActivation, true, true);
        theActivation = tempPtr;
    }

    auto theGroup = GetDefruleModuleItem(theEnv, nullptr)->groupings;
    while (theGroup != nullptr) {
        auto tempGroup = theGroup->getNext();
        rtn_struct(theEnv, SalienceGroup, theGroup);
        theGroup = tempGroup;
    }
}

/*******************************************************/
/* DetachActivation: Detaches the specified activation */
/*   from the list of activations on the Agenda.       */
/*******************************************************/
bool DetachActivation(
        const Environment&theEnv,
        Activation::Ptr theActivation) {
    struct defruleModule *theModuleItem;

    /*============================*/
    /* A nullptr pointer is invalid. */
    /*============================*/

    if (theActivation == nullptr) SystemError(theEnv, "AGENDA", 1);

    /*====================================*/
    /* Determine the module of the agenda */
    /* in which the activation is stored. */
    /*====================================*/

    theModuleItem = (defruleModule *) theActivation->getRule()->header.whichModule;

    RemoveActivationFromGroup(theEnv, theActivation, theModuleItem);

    /*========================================================*/
    /* If the activation is the top activation on the agenda, */
    /* then update the module pointer to agenda.              */
    /*========================================================*/

    if (theActivation == theModuleItem->agenda) { theModuleItem->agenda = theActivation->getNext(); }

    /*==================================================*/
    /* Update the pointers in the preceding activation. */
    /*==================================================*/

    if (theActivation->getPrevious() != nullptr) { theActivation->getPrevious()->setNext(theActivation->getNext()); }

    /*==================================================*/
    /* Update the pointers in the following activation. */
    /*==================================================*/

    if (theActivation->getNext() != nullptr) { theActivation->getNext()->setPrevious(theActivation->getPrevious()); }

    /*=================================================*/
    /* Update the pointers in the detached activation. */
    /*=================================================*/

    theActivation->setPrevious(nullptr);
    theActivation->setNext(nullptr);

    /*=============================*/
    /* Mark the agenda as changed. */
    /*=============================*/

    AgendaData(theEnv)->markAgendaHasChanged();

    return true;
}

/****************************************************************************/
/* PrintActivation: Prints an activation in a "pretty" format. Salience,    */
/*   rule name, and the partial match which activated the rule are printed. */
/****************************************************************************/
static void PrintActivation(
        const Environment&theEnv,
        const char *logicalName,
        Activation::Ptr theActivation) {
    char printSpace[20];

    gensprintf(printSpace, "%-6d ", theActivation->getSalience());
    WriteString(theEnv, logicalName, printSpace);
    WriteString(theEnv, logicalName, theActivation->getRule()->header.name->contents);
    WriteString(theEnv, logicalName, ": ");
    PrintPartialMatch(theEnv, logicalName, theActivation->getBasis());
}

/*****************************/
/* Agenda: C access routine  */
/*   for the agenda command. */
/*****************************/
void Agenda(
        const Environment&theEnv,
        const char *logicalName,
        Defmodule *theModule) {
    ListItemsDriver(theEnv, logicalName, theModule, "activation", "activations",
                    (GetNextItemFunction *) GetNextActivation,
                    nullptr,
                    (PrintItemFunction *) PrintActivation,
                    nullptr);
}

/*******************************************************************/
/* RemoveActivation: Returns an activation and its associated data */
/*   structures to the Memory Manager. Links to other activations  */
/*   and partial matches may also be updated.                      */
/*******************************************************************/
void RemoveActivation(
        const Environment&theEnv,
        Activation::Ptr theActivation,
        bool updateAgenda,
        bool updateLinks) {
    struct defruleModule *theModuleItem;

    /*====================================*/
    /* Determine the module of the agenda */
    /* in which the activation is stored. */
    /*====================================*/

    theModuleItem = (defruleModule *) theActivation->getRule()->header.whichModule;

    /*=================================*/
    /* Update the agenda if necessary. */
    /*=================================*/

    if (updateAgenda) {
        RemoveActivationFromGroup(theEnv, theActivation, theModuleItem);

        /*===============================================*/
        /* Update the pointer links between activations. */
        /*===============================================*/

        if (theActivation->getPrevious() == nullptr) {
            theModuleItem->agenda = theModuleItem->agenda->getNext() ;
            if (theModuleItem->agenda != nullptr) theModuleItem->agenda->setPrevious(nullptr);
        } else {
            theActivation->getPrevious()->setNext(theActivation->getNext());
            if (theActivation->getNext() != nullptr) { theActivation->getNext()->setPrevious(theActivation->getPrevious()); }
        }

        /*===================================*/
        /* Indicate removal of activation if */
        /* activations are being watched.    */
        /*===================================*/

#if DEBUGGING_FUNCTIONS
        if (theActivation->getRule()->watchActivation &&
            (!ConstructData(theEnv)->ClearReadyInProgress) &&
            (!ConstructData(theEnv)->ClearInProgress)) {
            WriteString(theEnv, STDOUT, "<== Activation ");
            PrintActivation(theEnv, STDOUT, theActivation);
            WriteString(theEnv, STDOUT, "\n");
        }
#endif

        /*=============================*/
        /* Mark the agenda as changed. */
        /*=============================*/

        AgendaData(theEnv)->markAgendaHasChanged();
    }

    /*============================================*/
    /* Update join and agenda links if necessary. */
    /*============================================*/

    if (updateLinks && (theActivation->getBasis() != nullptr)) { theActivation->getBasis()->marker = nullptr; }

    /*================================================*/
    /* Return the activation to the free memory pool. */
    /*================================================*/

    AgendaData(theEnv)->decrementActivationCount();

    rtn_struct(theEnv, Activation, theActivation);
}

/******************************/
/* RemoveActivationFromGroup: */
/******************************/
static void RemoveActivationFromGroup(
        const Environment&theEnv,
        Activation::Ptr theActivation,
        struct defruleModule *theRuleModule) {
    struct SalienceGroup *theGroup;

    theGroup = FindSalienceGroup(theRuleModule, theActivation->getSalience());
    if (theGroup == nullptr) return;

    if (theActivation == theGroup->getFirst()) {
        /*====================================================*/
        /* If the activation is the only remaining activation */
        /* in the group, then the group needs to be removed.  */
        /*====================================================*/

        if (theActivation == theGroup->getLast()) {
            if (theGroup->getPrevious() == nullptr) { theRuleModule->groupings = theGroup->getNext(); }
            else { theGroup->getPrevious()->setNext(theGroup->getNext()); }

            if (theGroup->getNext() != nullptr) { theGroup->getNext()->setPrevious( theGroup->getPrevious()); }

            rtn_struct(theEnv, SalienceGroup, theGroup);
        }

            /*======================================================*/
            /* Otherwise this is the first activation in the group, */
            /* but there are other activations which follow.        */
            /*======================================================*/

        else { theGroup->setFirst(theActivation->getNext()); }
    } else {
        /*====================================================*/
        /* Otherwise if the activation isn't the first in the */
        /* group, then check to see if it's the last.         */
        /*====================================================*/

        if (theActivation == theGroup->getLast()) { theGroup->setLast(theActivation->getPrevious()); }

            /*==================================================*/
            /* Otherwise the activation is in the middle of the */
            /* group and no first/last updates are needed.      */
            /*==================================================*/

        else { return; }
    }
}

/**************************************************************/
/* AgendaClearFunction: Agenda clear routine for use with the */
/*   clear command. Resets the current time tag to zero.      */
/**************************************************************/
static void AgendaClearFunction(
        const Environment&theEnv,
        void *context) {
    AgendaData(theEnv)->setCurrentTimetag(1);
}

/*************************************************/
/* RemoveAllActivations: Removes all activations */
/*   from the agenda of the current module.      */
/*************************************************/
void RemoveAllActivations(
        const Environment&theEnv) {
    Activation::Ptr tempPtr, theActivation;
    struct SalienceGroup *theGroup, *tempGroup;

    theActivation = GetDefruleModuleItem(theEnv, nullptr)->agenda;
    while (theActivation != nullptr) {
        tempPtr = theActivation->getNext();
        RemoveActivation(theEnv, theActivation, true, true);
        theActivation = tempPtr;
    }

    theGroup = GetDefruleModuleItem(theEnv, nullptr)->groupings;
    while (theGroup != nullptr) {
        tempGroup = theGroup->getNext();
        rtn_struct(theEnv, SalienceGroup, theGroup);
        theGroup = tempGroup;
    }
}

/**********************************************/
/* GetAgendaChanged: Returns the value of the */
/*   boolean flag which indicates whether any */
/*   changes have been made to the agenda.    */

/*****************************************************************/
/* SetAgendaChanged: Sets the value of the boolean flag which    */
/*   indicates whether any changes have been made to the agenda. */

/**********************/
/* ReorderAllAgendas: */
/**********************/
void ReorderAllAgendas(
        const Environment&theEnv) {
    Defmodule *theModule;

    for (theModule = GetNextDefmodule(theEnv, nullptr);
         theModule != nullptr;
         theModule = GetNextDefmodule(theEnv, theModule)) { ReorderAgenda(theModule); }
}

/*******************************************************/
/* ReorderAgenda: Completely reorders the agenda based */
/*   on the current conflict resolution strategy.      */
/*******************************************************/
void ReorderAgenda(
        Defmodule *theModule) {
    struct Activation::Ptr theActivation, *tempPtr;
    struct defruleModule *theModuleItem;
    struct SalienceGroup *theGroup, *tempGroup;
    Environment theEnv;

    if (theModule == nullptr) return;
    theEnv = theModule->header.env;

    /*=================================*/
    /* Get the list of activations and */
    /* remove them from the agenda.    */
    /*=================================*/

    theModuleItem = GetDefruleModuleItem(theEnv, theModule);
    theActivation = theModuleItem->agenda;
    theModuleItem->agenda = nullptr;

    theGroup = theModuleItem->groupings;
    while (theGroup != nullptr) {
        tempGroup = theGroup->getNext();
        rtn_struct(theEnv, SalienceGroup, theGroup);
        theGroup = tempGroup;
    }

    theModuleItem->groupings = nullptr;

    /*=========================================*/
    /* Reorder the activations by placing them */
    /* back on the agenda one by one.          */
    /*=========================================*/

    while (theActivation != nullptr) {
        tempPtr = theActivation->getNext();
        theActivation->setNext(nullptr);
        theActivation->setPrevious(nullptr);
        theGroup = ReuseOrCreateSalienceGroup(theEnv, theModuleItem, theActivation->getSalience());
        PlaceActivation(theEnv, &(theModuleItem->agenda), theActivation, theGroup);
        theActivation = tempPtr;
    }
}

/****************************************************/
/* GetNumberOfActivations: Returns the value of the */
/*   total number of activations on all agendas.    */

/******************************************************/
/* RefreshCommand: H/L Command for refreshing a rule. */
/*   Syntax: (refresh <defrule-name>)                 */
/******************************************************/
void RefreshCommand(
        const Environment&theEnv,
        UDFContext *context,
        UDFValue *returnValue) {
    /*===========================*/
    /* Get the name of the rule. */
    /*===========================*/

    auto ruleName = GetConstructName(context, "refresh", "rule name");
    if (ruleName == nullptr) return;

    /*===============================*/
    /* Determine if the rule exists. */
    /*===============================*/

    auto rulePtr = FindDefrule(theEnv, ruleName);
    if (rulePtr == nullptr) {
        CantFindItemErrorMessage(theEnv, "defrule", ruleName, true);
        return;
    }

    /*===================*/
    /* Refresh the rule. */
    /*===================*/

    Refresh(rulePtr);
}

/***********************************************************/
/* Refresh: Refreshes a defrule. Activations of the rule   */
/*   that have already been fired are added to the agenda. */
/***********************************************************/
void Refresh(
        Defrule::Ptr theRule) {
    Defrule::Ptr rulePtr;
    PartialMatch *listOfMatches;
    unsigned long b;
    const Environment&theEnv = theRule->header.env;

    /*====================================*/
    /* Refresh each disjunct of the rule. */
    /*====================================*/

    for (rulePtr = theRule;
         rulePtr != nullptr;
         rulePtr = rulePtr->disjunct) {
        /*================================*/
        /* Check each partial match that  */
        /* satisfies the LHS of the rule. */
        /*================================*/

        for (b = 0; b < rulePtr->lastJoin->leftMemory->size; b++) {
            for (listOfMatches = rulePtr->lastJoin->leftMemory->beta[b];
                 listOfMatches != nullptr;
                 listOfMatches = listOfMatches->nextInMemory) {
                /*=======================================================*/
                /* If the partial match is associated with an activation */
                /* (which it should always be), then place a new         */
                /* activation on the agenda if this partial matchdoesn't */
                /* have an activation associated with it.                */
                /*=======================================================*/

                if (((joinNode *) listOfMatches->owner)->ruleToActivate != nullptr) {
                    if (listOfMatches->marker == nullptr) { AddActivation(theEnv, rulePtr, listOfMatches); }
                }
            }
        }
    }
}

/**********************************************/
/* RefreshAgendaCommand: H/L access routine   */
/*   for the refresh-agenda command.          */
/**********************************************/
void RefreshAgendaCommand(
        const Environment&theEnv,
        UDFContext *context,
        UDFValue *returnValue) {
    unsigned int numArgs;
    bool error;
    Defmodule *theModule;

    /*==============================================*/
    /* This function can have at most one argument. */
    /*==============================================*/

    numArgs = UDFArgumentCount(context);

    /*===============================================================*/
    /* If a module name is specified, then the agenda of that module */
    /* is refreshed. Otherwise, the agenda of the current module is  */
    /* refreshed.                                                    */
    /*===============================================================*/

    if (numArgs == 1) {
        theModule = GetModuleName(context, 1, &error);
        if (error) return;
    } else { theModule = GetCurrentModule(theEnv); }

    /*===============================================*/
    /* Refresh the agenda of the appropriate module. */
    /*===============================================*/

    if (theModule == nullptr) { RefreshAllAgendas(theEnv); }
    else { RefreshAgenda(theModule); }
}

/**********************/
/* RefreshAllAgendas: */
/**********************/
void RefreshAllAgendas(
        const Environment&theEnv) {
    Defmodule *theModule;

    for (theModule = GetNextDefmodule(theEnv, nullptr);
         theModule != nullptr;
         theModule = GetNextDefmodule(theEnv, theModule)) { RefreshAgenda(theModule); }
}

/*************************************/
/* RefreshAgenda: C access routine   */
/*   for the refresh-agenda command. */
/*************************************/
void RefreshAgenda(
        Defmodule *theModule) {
    Activation::Ptr theActivation;
    SalienceEvaluationType oldValue;
    Environment theEnv;

    if (theModule == nullptr) return;
    theEnv = theModule->header.env;

    /*=====================================*/
    /* If embedded, clear the error flags. */
    /*=====================================*/

    if (EvaluationData(theEnv)->CurrentExpression == nullptr) { ResetErrorFlags(theEnv); }

    /*==========================*/
    /* Save the current module. */
    /*==========================*/

    SaveCurrentModule(theEnv);

    /*=======================================================*/
    /* Remember the current setting for salience evaluation. */
    /* To perform the refresh, the when activated setting is */
    /* used to recompute the salience values.                */
    /*=======================================================*/

    oldValue = GetSalienceEvaluation(theEnv);
    SetSalienceEvaluation(theEnv, WHEN_ACTIVATED);

    /*============================*/
    /* Change the current module. */
    /*============================*/

    SetCurrentModule(theEnv, theModule);

    /*================================================================*/
    /* Recompute the salience values for the current module's agenda. */
    /*================================================================*/

    for (theActivation = GetNextActivation(theEnv, nullptr);
         theActivation != nullptr;
         theActivation = GetNextActivation(theEnv, theActivation)) {
        theActivation->setSalience(EvaluateSalience(theEnv, theActivation->getRule()));
    }

    /*======================================================*/
    /* Reorder the agenda based on the new salience values. */
    /*======================================================*/

    ReorderAgenda(theModule);

    /*==========================================*/
    /* Restore the salience evaluation setting. */
    /*==========================================*/

    SetSalienceEvaluation(theEnv, oldValue);

    /*=============================*/
    /* Restore the current module. */
    /*=============================*/

    RestoreCurrentModule(theEnv);
}

/*********************************************************/
/* SetSalienceEvaluationCommand: H/L Command for setting */
/*   the salience evaluation behavior.                   */
/*   Syntax: (set-salience-evaluation-behavior <symbol>) */
/*********************************************************/
void SetSalienceEvaluationCommand(
        const Environment&theEnv,
        UDFContext *context,
        UDFValue *returnValue) {
    UDFValue value;
    const char *argument;
    const char *oldValue;

    /*==================================================*/
    /* Get the current setting for salience evaluation. */
    /*==================================================*/

    oldValue = SalienceEvaluationName(GetSalienceEvaluation(theEnv));

    /*=========================================*/
    /* This function expects a single argument */
    /* which must be a symbol.                 */
    /*=========================================*/

    if (!UDFFirstArgument(context, SYMBOL_BIT, &value)) { return; }

    /*=============================================================*/
    /* The allowed symbols to pass as an argument to this function */
    /* are when-defined, when-activated, and every-cycle.          */
    /*=============================================================*/

    argument = value.lexemeValue->contents;

    if (strcmp(argument, "when-defined") == 0) { SetSalienceEvaluation(theEnv, WHEN_DEFINED); }
    else if (strcmp(argument, "when-activated") == 0) { SetSalienceEvaluation(theEnv, WHEN_ACTIVATED); }
    else if (strcmp(argument, "every-cycle") == 0) { SetSalienceEvaluation(theEnv, EVERY_CYCLE); }
    else {
        UDFInvalidArgumentMessage(context,
                                  "symbol with value when-defined, when-activated, or every-cycle");
        returnValue->lexemeValue = CreateSymbol(theEnv, oldValue);
        return;
    }

    /*=================================================*/
    /* Return the old setting for salience evaluation. */
    /*=================================================*/

    returnValue->lexemeValue = CreateSymbol(theEnv, oldValue);
}

/*********************************************************/
/* GetSalienceEvaluationCommand: H/L Command for getting */
/*   the salience evaluation behavior.                   */
/*   Syntax: (get-salience-evaluation-behavior)          */
/*********************************************************/
void GetSalienceEvaluationCommand(
        const Environment&theEnv,
        UDFContext *context,
        UDFValue *returnValue) {
    returnValue->lexemeValue = CreateSymbol(theEnv, SalienceEvaluationName(GetSalienceEvaluation(theEnv)));
}

/*****************************************************************/
/* SalienceEvaluationName: Given the integer value corresponding */
/*   to a specified salience evaluation behavior, returns a      */
/*   character string of the behavior's name.                    */
/*****************************************************************/
static const char *SalienceEvaluationName(
        SalienceEvaluationType strategy) {
    const char *sname;

    switch (strategy) {
        case WHEN_DEFINED:
            sname = "when-defined";
            break;
        case WHEN_ACTIVATED:
            sname = "when-activated";
            break;
        case EVERY_CYCLE:
            sname = "every-cycle";
            break;
        default:
            sname = "unknown";
            break;
    }

    return sname;
}

/*******************************************************/
/* GetSalienceEvaluation: Returns the value of current */
/*  type of salience evaluation (e.g., when defined,   */
/*  when activated, or every cycle).                   */
/*******************************************************/
SalienceEvaluationType GetSalienceEvaluation(
        const Environment&theEnv) {
    return AgendaData(theEnv)->getSalienceEvaluation();
}

/**********************************************/
/* SetSalienceEvaluation: Sets the value of   */
/*   the current type of salience evaluation. */
/**********************************************/
SalienceEvaluationType SetSalienceEvaluation(
        const Environment&theEnv,
        SalienceEvaluationType value) {
    SalienceEvaluationType ov;

    ov = AgendaData(theEnv)->getSalienceEvaluation();
    AgendaData(theEnv)->setSalienceEvaluation(value);
    return ov;
}

/*****************************************************************/
/* EvaluateSalience: Returns the salience value of the specified */
/*   defrule. If salience evaluation is currently set to         */
/*   when-defined, then the current value of the rule's salience */
/*   is returned. Otherwise the salience expression associated   */
/*   with the rule is reevaluated, the value is stored as the    */
/*   rule's current salience, and it is then returned.           */
/*****************************************************************/
static int EvaluateSalience(
        const Environment&theEnv,
        Defrule::Ptr theDefrule) {
    UDFValue salienceValue;
    long long salience;

    /*==================================================*/
    /* If saliences are only being evaluated when rules */
    /* are defined, then just return the last salience  */
    /* value evaluated for the rule.                    */
    /*==================================================*/

    if (GetSalienceEvaluation(theEnv) == WHEN_DEFINED) { return theDefrule->salience; }

    /*=================================================================*/
    /* If the rule's salience value was defined as an integer constant */
    /* (i.e., not an expression or global variable which could change  */
    /* on reevaluation), then just return the salience value computed  */
    /* for the rule when it was defined.                               */
    /*=================================================================*/

    if (theDefrule->dynamicSalience == nullptr) return theDefrule->salience;

    /*====================================================*/
    /* Reevaluate the rule's salience. If an error occurs */
    /* during evaluation, print an error message.         */
    /*====================================================*/

    SetEvaluationError(theEnv, false);
    if (EvaluateExpression(theEnv, theDefrule->dynamicSalience, &salienceValue)) {
        SalienceInformationError(theEnv, "defrule", theDefrule->header.name->contents);
        return theDefrule->salience;
    }

    /*========================================*/
    /* The salience value must be an integer. */
    /*========================================*/

    if (salienceValue.header->type != INTEGER_TYPE) {
        SalienceNonIntegerError(theEnv);
        SalienceInformationError(theEnv, "defrule", theDefrule->header.name->contents);
        SetEvaluationError(theEnv, true);
        return theDefrule->salience;
    }

    /*==========================================*/
    /* The salience value must fall between the */
    /* minimum and maximum allowed values.      */
    /*==========================================*/

    salience = salienceValue.integerValue->contents;

    if ((salience > MAX_DEFRULE_SALIENCE) || (salience < MIN_DEFRULE_SALIENCE)) {
        SalienceRangeError(theEnv, MIN_DEFRULE_SALIENCE, MAX_DEFRULE_SALIENCE);
        SetEvaluationError(theEnv, true);
        SalienceInformationError(theEnv, "defrule", theDefrule->header.name->contents);
        return theDefrule->salience;
    }

    /*===================================*/
    /* Store the new salience value with */
    /* the rule and return this value.   */
    /*===================================*/

    theDefrule->salience = (int) salience;
    return theDefrule->salience;
}

#if DEBUGGING_FUNCTIONS

/***********************************************/
/* AgendaCommand: Prints out the agenda of the */
/*   rules that are ready to fire.             */
/*   Syntax: (agenda)                          */
/***********************************************/
void AgendaCommand(
        const Environment&theEnv,
        UDFContext *context,
        UDFValue *returnValue) {
    unsigned int numArgs;
    bool error;
    Defmodule *theModule;

    /*===============================================================*/
    /* If a module name is specified, then the agenda of that module */
    /* is displayed. Otherwise, the agenda of the current module is  */
    /* displayed.                                                    */
    /*===============================================================*/

    numArgs = UDFArgumentCount(context);
    if (numArgs == 1) {
        theModule = GetModuleName(context, 1, &error);
        if (error) return;
    } else { theModule = GetCurrentModule(theEnv); }

    /*===============================================*/
    /* Display the agenda of the appropriate module. */
    /*===============================================*/

    Agenda(theEnv, STDOUT, theModule);
}

#endif /* DEBUGGING_FUNCTIONS */


